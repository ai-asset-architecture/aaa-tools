from .schema import Policy, Rule, CheckType
from typing import List

class Generator:
    """
    Compiles a Policy object into a standard Python check script.
    """
    
    @staticmethod
    def generate(policy: Policy) -> str:
        lines = []
        lines.append(f"# Generated by AAA Governance Compiler v1.3")
        lines.append(f"# Policy: {policy.metadata.name} (v{policy.metadata.version})")
        lines.append("import sys")
        lines.append("from pathlib import Path")
        lines.append("import json")
        lines.append("import re")
        lines.append("")
        lines.append("# --- Helper Functions ---")
        lines.append(Generator._get_helpers())
        lines.append("")
        lines.append("def main():")
        lines.append("    violations = []")
        lines.append(f"    print('Running Policy: {policy.metadata.name}')")
        
        for rule in policy.rules:
            lines.append(f"    # Rule: {rule.id}")
            lines.append(Generator._generate_check_logic(rule))
            
        lines.append("")
        lines.append("    if violations:")
        lines.append("        print('\\n❌ Policy Violations Found:')")
        lines.append("        for v in violations:")
        lines.append("            print(f'  - [{v[\"severity\"]}] {v[\"id\"]}: {v[\"message\"]}')")
        lines.append("        sys.exit(1)")
        lines.append("    else:")
        lines.append("        print('\\n✅ All checks passed.')")
        lines.append("        sys.exit(0)")
        lines.append("")
        lines.append("if __name__ == '__main__':")
        lines.append("    main()")
        
        return "\n".join(lines)

    @staticmethod
    def _get_helpers() -> str:
        return """
def check_file_exists(path: str) -> bool:
    return Path(path).exists()

def check_content_contains(path: str, pattern: str) -> bool:
    p = Path(path)
    if not p.exists(): return False
    content = p.read_text(encoding='utf-8')
    return re.search(pattern, content) is not None

def check_json_match(path: str, key_path: str, expected) -> bool:
    p = Path(path)
    if not p.exists(): return False
    try:
        data = json.loads(p.read_text(encoding='utf-8'))
        keys = key_path.split('.')
        val = data
        for k in keys:
            if isinstance(val, dict): val = val.get(k)
            else: return False
        return val == expected
    except:
        return False
"""

    @staticmethod
    def _generate_check_logic(rule: Rule) -> str:
        check = rule.check
        # Logic block indentation: 4 spaces (inside main)
        block = []
        
        if check.type == CheckType.FILE_EXISTS:
            block.append(f"    if not check_file_exists('{check.path}'):")
            block.append(f"        violations.append({{'id': '{rule.id}', 'severity': '{rule.severity.value}', 'message': 'File not found: {check.path}'}})")
            
        elif check.type == CheckType.CONTENT_CONTAINS:
            block.append(f"    if not check_content_contains('{check.path}', r'{check.pattern}'):")
            block.append(f"        violations.append({{'id': '{rule.id}', 'severity': '{rule.severity.value}', 'message': 'File {check.path} missing pattern: {check.pattern}'}})")
            
        elif check.type == CheckType.JSON_MATCH:
            # Handle string vs int vs bool for expected value in generated code
            expected_repr = repr(check.expected_value)
            block.append(f"    if not check_json_match('{check.path}', '{check.key_path}', {expected_repr}):")
            block.append(f"        violations.append({{'id': '{rule.id}', 'severity': '{rule.severity.value}', 'message': 'JSON {check.path} key {check.key_path} != {expected_repr}'}})")
            
        return "\n".join(block)
